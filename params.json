{"name":"Building a rhythm game using Haskell","tagline":"","body":"Creating rhythm game with Haskell\r\n====\r\nFumiaki Kinoshita (part-time employee of IIJ-II) fumiexcel@gmail.com\r\n\r\nIntroduction\r\n----\r\nRhythm games, also known as rhythm actions, are very popular genre in Japan. Konami released __Dance Dance Revolution (DDR) in 1998__ -- it is the best successful game among the genre. Another famous one, _Taiko no Tatsujin_(literally, __Expert of Japanese drum__) is being immensely supported by broad age-group of people. Today, various forms of rhythm games have been released one after another.\r\n\r\nHowever, there are few tutorials to create such kind of games. Even if there are, they might be too old, or written in non-English, or/and work only in Windows.\r\n\r\nThis tutorial focuses on creating a rhythm game without pain. Don't be surprised, we use Haskell to do that.\r\n\r\nThis tutorial has two parts.\r\n\r\n* Part I contains an instruction to set up environment required for Part II and III.\r\n* In Part II, we build a very simple rhythm game. We use the Call engine to develop.\r\n* Part III introduces some technical backgrounds (graphics, audio) that support Part II.\r\n\r\nI'd be happy if this tutorial helps your curiosity to create a game.\r\n\r\nPart I: Preparation\r\n----\r\n\r\nWe need to ensure that you have installed GHC. [Haskell Platform](https://www.haskell.org/platform/) is an easy way to install GHC.\r\n\r\nOn Unix or Mac, install `libportaudio19`.\r\n\r\n```\r\n$ sudo <your-package-manager> install libportaudio19\r\n```\r\n\r\nThe source code used in this tutorial is packed in `rhythm-game-tutorial` package. You can download it and set it up by:\r\n\r\n```\r\n$ cabal unpack rhythm-game-tutorial\r\n$ cd rhythm-game-tutorial-<version>\r\n$ cabal install --only-dependencies\r\n% cabal configure\r\n$ cabal build\r\n```\r\n\r\n`cabal install --only-dependencies` installs a bunch of packages, including two vital packages: `objective` and `call`.\r\n\r\n* `objective` establishes abstraction for stateful objects. It is not neccessary strictly, though it kills the pain of state significantly.\r\n* `call` is a cross-platform multimedia library. While it is small and simple, the essentials of games (2D/3D graphics, audio, input handing from keyboard, mouse and gamepad) is assurable.\r\n* `binding-portaudio` is low-level audio APIs.\r\n\r\n### On windows\r\n\r\nUnfortunately, installing `bindings-portaudio` is magical on Windows. So, `bindings-portaudio` provides built-in source for installation ease. Note that using 32-bit version of GHC is safer to avoid problems if your platform is Windows x64.\r\n\r\n> $ cabal install bindings-portaudio -fBundle -fWASAPI\r\n\r\nIf it throws up something messy, please report to me.\r\n\r\nPart II: Creating a game\r\n-------------------------------------------------\r\n\r\n> Here we bang! -- Wada-don, \"Taiko no Tatsujin\"\r\n\r\nNow, think of a very simple game: There's a circle at the bottom of the window, and another circle(s) is approaching. You hit the space key in exact timing when the another circle overlapped the original one.\r\n\r\n![tutorial-passive](images/tutorial-passive-screenshot.png)\r\n\r\nHow do we implement this? The structure of the program can be derived by writing components down:\r\n\r\n* Sound: a music is playing through the game.\r\n* Graphics: pictures depend on the time.\r\n* User interaction: the score changes when the player hit the space key.\r\n\r\nWe will explain these in order.\r\n\r\n### Playing a music\r\n\r\nGroove is important. It's time to play a music. Our first game is as follows(`src/music-only.hs`):\r\n\r\n```haskell\r\nmain = runSystemDefault $ do\r\n  music <- prepareMusic \"assets/Monoidal Purity.wav\"\r\n  playMusic music\r\n  stand\r\n```\r\n\r\nLet's execute it:\r\n\r\n```shell\r\n$ dist/build/music-only/music-only\r\n```\r\n\r\nCan you hear the music? Note that it takes a moment to load a music.\r\n\r\nLet's investigate the code. The following functions are provided by Call engine.\r\n\r\n```haskell\r\nrunSystemDefault :: (forall s. System s a) -> IO a\r\nstand :: System s ()\r\n```\r\n\r\nIn Call, actions are performed on `System s` monad. `runSystemDefault` converts `System s` into `IO`. `stand` does nothing, preventing termination of the program.\r\n\r\nThe signatures of `prepareMusic` and `playMusic` are as follows:\r\n\r\n```haskell\r\ntype Music s = Inst (System s) (StateT Deck (System s)) (System s)\r\n\r\nprepareMusic :: FilePath -> System s Music\r\nplayMusic :: Music -> System s ()\r\n```\r\n\r\nThese functions will be defined later.\r\n\r\n### Drawing a picture\r\n\r\nLet's construct a graphical part of the game.\r\n\r\n```haskell\r\nmain = runSystemDefault $ do\r\n  allTimings <- liftIO $ (!!0) <$> parseTimings (60/140*4) <$> readFile \"assets/Monoidal-Purity.txt\"\r\n  linkPicture $ \\_ -> renderLane allTimings <$> getTime\r\n  stand\r\n```\r\n\r\n`linkPicture :: (Time -> System s Picture) -> System ()` is the only function provided by Call to actually draw something.`linkPicture f` repeatedly calls `f` and draws the result of `f` to the window. The argument of `f` is the time difference between frames, it is often negilible though.\r\n\r\nDue to its game system, we need to prepare the set of times. Let us introduce a new notation to represent timings which is more readable than just the list of decimals.\r\n\r\nThis notation is consist of a number of packets, representing a sequence of bars. Each packets contain several lines. A bar is divided by the length of line. '.' and '-' represents a note and a rest.\r\n\r\n    ----.-----------\r\n    .-----------.---\r\n    --------.-------\r\n\r\nThe implementation of the parser is not so interesting.\r\n\r\n```haskell\r\nparseTimings :: String -> [Set Time]\r\n```\r\n\r\nGiven timings and \"life span\" of circles, we can compute positions of visible circles from the time.\r\n\r\n```haskell\r\nphases :: Set Time -- ^ timings\r\n    -> Time -- ^ life span\r\n    -> Time -- ^ the current time\r\n    -> [Float] -- ^ phase\r\nphases s len t = map ((/len) . subtract t) -- transform to an interval [0, 1]\r\n  $ Set.toList\r\n  $ fst $ Set.split (t + len) s -- before the limit\r\n```\r\n\r\nCreate a function to render circles. Since `Picture` is a monoid, we can use `foldMap` or `mconcat` to combine pictures. `translate (V2 x y)` shifts the picture into (x, y). `bitmap b` turns a `Bitmap` into a `Picture`.\r\n\r\n```haskell\r\ncircle_png :: Bitmap\r\ncircle_png = unsafePerformIO $ readBitmap \"assets/circle.png\"\r\n\r\ncircles :: [Float] -> Picture\r\ncircles = foldMap (\\p -> V2 320 ((1 - p) * 480) `translate` bitmap circle_png)\r\n```\r\n\r\n`renderLane` passes the result of `phases` into `circles`. `color` changes a color of a picture.\r\n\r\n```haskell\r\nrenderLane :: Set Time -> Time -> Picture\r\nrenderLane ts t = mconcat [color blue $ circles (phases ts 1 t)\r\n    , V2 320 480 `translate` color black (bitmap circle_png) -- criterion\r\n    ]\r\n```\r\n\r\nHere is an updated `main`.\r\n\r\n```haskell\r\nmain = runSystemDefault $ do\r\n  music <- prepareMusic \"assets/Monoidal-Purity.wav\"\r\n  allTimings <- fmap (!!0) $ liftIO $ loadTimings \"assets/Monoidal-Purity.txt\"\r\n  linkPicture $ \\_ -> renderLane allTimings <$> getTime\r\n  playMusic music\r\n  stand\r\n```\r\n\r\nThere is a serious problem in this program. The graphics and music may __diverge__ when the program has stumbled accidentally. We need to use the musical time instead of the real one.\r\n\r\n### Component: prepareMusic\r\n\r\nA music is essential for rhythm games.\r\n\r\n```haskell\r\ntype Music s = InstOf (System s) (Variable Deck)\r\n\r\nprepareMusic :: FilePath -> System s Music\r\nprepareMusic path = do\r\n  wav <- readWAVE path\r\n  i <- new $ variable $ source .~ sampleSource wav $ Deck.empty\r\n  linkAudio $ playbackOf i\r\n  return i\r\n```\r\n\r\n`readWAVE` loads a sound from `.wav` file.`source .~ sampleSource wav $ Deck.empty` is a bit tricky.\r\n\r\nDeck is an utility to play a music. `source` is a `Lens` which is purely functional representation of accessors. This tutorial explains about `Lens` later, in Part III. `new $ variable $ v` instantiates a music. Regard `linkAudio $ playbackOf i` as a cliché for now.\r\n\r\n### Component: getPosition and playMusic\r\n\r\nThe implementation of `getPosition` and `playMusic` is as follows:\r\n\r\n```haskell\r\ngetPosition :: Music s -> System s Time\r\ngetPosition m = m .- use pos\r\n\r\nplayMusic :: Music s -> System s ()\r\nplayMusic m = m .- playing .= True\r\n```\r\n\r\nYou notice two new operators: `use` and `.=`. These comes from the `lens` library. This package contains types and utilities to deal with various accessors.\r\n\r\n`pos`, `playing` are `Lens`. Given `Lens' s a`, you can take and modify a value `a` from `s`.\r\n\r\n```haskell\r\npos :: Lens' Deck Time\r\nplaying :: Lens' Deck Bool\r\n```\r\n\r\n`use` and `(.=)` are getting/setting operators that work on stateful monads.\r\n\r\n```haskell\r\nuse :: MonadState s m => Lens' s a -> m a\r\n(.=) :: MonadState s m => Lens' s a -> a -> m ()\r\n```\r\n\r\nWith lens, we can access a specific element of a structure easily, allowing you manipulate just like \"fields\" in OOP languages. However, the state of the deck is packed in `music` in `gameMain` so these can't be used directly. The `(.-)` operator, provided by `objective` package, executes an action within a context held by a left operand.\r\n\r\n`getPosition m` returns an accurate time (in seconds) elapsed from an origin of a music `m`.\r\n\r\nPutting them together, we got `src/tutorial-passive.hs`.\r\n\r\n```shell\r\n$ dist/build/tutorial-passive/tutorial-passive\r\n```\r\n\r\nIt is not a game though -- simply because it has no score, no interaction.\r\n\r\n### Handling inputs\r\n\r\nLet's deal with inputs. Now introduce two components, `rate` and `handle`.\r\n\r\n```haskell\r\nrate :: Time -> Int\r\nrate dt\r\n  | dt < 0.05 = 4\r\n  | dt < 0.1 = 2\r\n  | otherwise = 1\r\n\r\nhandle :: Time -> Set Time -> (Int, Set Time)\r\nhandle t ts = case viewNearest t ts of\r\n  Nothing -> (0, ts) -- The song is over\r\n  Just (t', ts') -> (rate $ abs (t - t'), ts')\r\n```\r\n\r\n`rate` calculates a score from a time lag. `handle` returns a score and updated timings. `viewNearest :: (Num a, Ord a) => a -> Set a -> (a, Set a)` is a function to pick up the nearest value from a set. If we fail to attend to remove a nearest one, flamming the button causes undesired score increment.\r\n\r\n```haskell\r\ndata Chatter a = Up a | Down a\r\n```\r\n\r\nAnd the following code actually handles events:\r\n\r\n```haskell\r\nlinkKeyboard $ \\ev -> case ev of\r\n  Down KeySpace -> do\r\n    t <- getPosition\r\n    ts <- timings .- get\r\n    (sc, ts') <- handle t ts\r\n    timings .- put ts'\r\n    score .- modify (+sc)\r\n  _ -> return () -- Discard the other events\r\n```\r\n\r\nNote that a few variables has instantiated.\r\n\r\n```haskell\r\ntimings <- new $ variable (allTimings !! 0)\r\nscore <- new $ variable 0\r\n```\r\n\r\nAfter `linkKeyboard` is called, the engine passes keyboard events `Key`. `Key` is wrapped by `Chatter` to indicate that a key is pressed, or released. When the space key is pressed, it computes the time difference from the nearest timing and increment the score by accuracy.\r\n\r\nWe need to load a _Font_ as we want to show players the current score. `Call.Util.Text.simple` generates a function that renders a supplied text.\r\n\r\n```haskell\r\ntext <- Text.simple defaultFont 24 -- text :: String -> Picture\r\n```\r\n\r\nJust add `text (show sc)` to `renderGame`. `src/tutorial-active.hs` is the updated source we made interactive. It's a game, yay!\r\n\r\n```shell\r\n$ dist/build/tutorial-passive/tutorial-active\r\n```\r\n\r\n![tutorial-active](images/tutorial-active-screenshot.png)\r\n\r\n### Extending the game\r\n\r\nHowever, when you actually play this, you may feel dissatisfied. It is because the interaction is still poor. If it would have more showy effects, it'll be exciting. Most rhythm games shows the recent evaluation of accuracy immediately. So, players can notice whether their playing is good or bad.\r\n\r\nThanks to purely functional design, we can extend lanes so easily(`tutorial-extended.hs`)!\r\n\r\n![extended](images/extended.png)\r\n\r\n`ix i` is a lens that points an `i`-th element of a list. Just arrange the result of `forM` using `translate`.\r\n\r\nAnother interesting feature, `transit`, is convenient to create animations.\r\n\r\n```haskell\r\npop :: Bitmap -> Object (Request Time Picture) Maybe\r\npop bmp = Control.Object.transit 0.5 $ \\t -> translate (V2 320 360)\r\n  $ translate (V2 0 (-80) ^* t)\r\n  $ color (V4 1 1 1 (realToFrac $ 1 - t))\r\n  $ bitmap bmp\r\n```\r\n\r\nThe argument `t` varies from 0 to 1, for 0.5 seconds. To instantiate, put this object into a list:\r\n\r\n```haskell\r\neffects <- new $ variable []\r\neffects .- modify (pop _perfect_png:)\r\n```\r\n\r\nAnd `effects .- announceMaybe (request dt)` returns `[Picture]`, removing expired animations automatically. It benefits from `objective` much. Here is the complete `linkPicture` section.\r\n\r\n```haskell\r\nlinkPicture $ \\_ -> do\r\n  [l0, l1, l2] <- forM [0..2] $ \\i -> renderLane <$> (timings .- use (ix i)) <*> getPosition music\r\n  s <- score .- get\r\n  ps <- effects .- announceMaybe (request dt)\r\n  return $ translate (V2 (-120) 0) l0\r\n    <> translate (V2 0 0) l1\r\n    <> translate (V2 120 0) l2\r\n    <> color black (translate (V2 240 40) (text (show s)))\r\n    <> mconcat ps\r\n```\r\n\r\nThere is no difficulty around input.\r\n\r\n```haskell\r\nlet touchLane i = do\r\n      ((sc, obj), ts') <- handle <$> getPosition music <*> (timings .- use (ix i))\r\n      effects .- modify (obj:)\r\n      timings .- ix i .= ts'\r\n      score .- modify (+sc)\r\n\r\nlinkKeyboard $ \\ev -> case ev of\r\n  Down KeySpace -> touchLane 1\r\n  Down KeyF -> touchLane 0\r\n  Down KeyJ -> touchLane 2\r\n  _ -> return () -- Discard the other events\r\n```\r\n\r\nThe overall game goes in just 120 lines!\r\n\r\n```shell\r\n$ dist/build/tutorial-passive/tutorial-extended\r\n```\r\n\r\nPart III: Technical background\r\n-----------------\r\n\r\n### Graphics\r\n\r\nMonoid is the general term for composable stuff which has \"empty\". A picture is one of the monoids since there is an __empty picture__ and pictures __can be composed__ by overlaying. The standard library `base` provides a typeclass for monoids:\r\n\r\n```haskell\r\nclass Monoid a where\r\n  mempty :: a\r\n  mappend :: a -> a -> a\r\n```\r\n\r\nCall uses _free monoid_ to represent picture.\r\n\r\nIn de-CPSed form,\r\n\r\n```haskell\r\ndata Scene = Empty\r\n  | Combine Scene Scene\r\n  | Primitive Bitmap PrimitiveMode (Vector Vertex) -- draw a primitive\r\n  | VFX (VFX Scene) -- apply visual effects\r\n  | Transform (M44 Float) Scene -- transform `Scene` using a matrix\r\n```\r\n\r\nIts Monoid instance is trivial.\r\n\r\n```haskell\r\ninstance Monoid Scene where\r\n  mempty = Empty\r\n  mappend = Combine\r\n```\r\n\r\nUsing free monoid, we can isolate the drawing process from `Scene`. Think of `drawScene :: Scene -> IO ()` which calls concrete APIs to draw Scene. For empty picture, we don't do nothing. `Combine a b` is equivalent to calling `drawScene a >> drawScene b`.\r\n\r\nSo the implementation of `drawScene` will be as follows:\r\n\r\n```haskell\r\ndrawScene Empty = return ()\r\ndrawScene (Combine a b) = drawScene a >> drawScene b\r\ndrawScene (Primitive b m vs) = drawPrimitive b m vs\r\ndrawScene (VFX v) = drawScene (applyVFX v)\r\ndrawScene (Transform mat s) = withMatrix mat (drawScene s)\r\n```\r\n\r\nwhere `drawPrimitive`, `applyVFX`, `withMatrix` is environment-dependent.\r\n\r\nIn other words, free structures is a kind of DSL which encourages the reusability and independence of programs. Andres Löh's [Monads for free!](https://skillsmatter.com/skillscasts/4430-monads-for-free) is a great introduction for free structures.\r\n\r\nCall puts together a few kinds of transformation in `Affine` class. Thanks to type families, we can use the same operation for both 2D and 3D. `Normal` is the normal vector, which is 3-dimensional vector in 3D but it is just `Float` in 2D.\r\n\r\n```haskell\r\nclass Affine a where\r\n  type Vec a :: *\r\n  type Normal a :: *\r\n  rotateOn :: Normal a -> a -> a\r\n  scale :: Vec a -> a -> a\r\n  translate :: Vec a -> a -> a\r\n```\r\n\r\n### Audio\r\n\r\nCurrently, there are few packages for audio that work in common platforms and are easy to install. I choosed `portaudio` for now which supports a bunch of backends. Humans are so sensitive about sound. 20 miliseconds of latency is noticable for us.\r\n\r\nThus, it is important to minimize latency when it comes to audio. The raw `portaudio` uses the callback model. This is the main reason of why call relies on callback. `objective` package contributes to relax the pain of handling events and states. The call library aims to be small and concrete so that it only provides a way to interact with the machine.\r\n\r\nAcknowledgements\r\n-------------------------\r\nSpecial thanks to Kazuhiko Yamamoto for guidance of the architecture of this tutorial.","google":"UA-57795243-1","note":"Don't delete this file! It's used internally to help with page regeneration."}