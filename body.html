<h1 id="creating-rhythm-game-with-haskell">Creating rhythm game with Haskell</h1>
<p>Fumiaki Kinoshita (part-time employee of IIJ-II) fumiexcel@gmail.com</p>
<p><a href="http://fumieval.github.com/rhythm-game-tutorial/ja.html">日本語版</a> is available. Thank you, <span class="citation">@stefafafan</span>!</p>
<h2 id="introduction">Introduction</h2>
<p>Rhythm games, also known as rhythm actions, are very popular genre in Japan. Konami released <strong>Dance Dance Revolution (DDR) in 1998</strong> -- it is the best successful game among the genre. Another famous one, <em>Taiko no Tatsujin</em>(literally, <strong>Expert of Japanese drum</strong>) is being immensely supported by broad age-group of people. Today, various forms of rhythm games have been released one after another.</p>
<p>However, there are few tutorials to create such kind of games. Even if there are, they might be too old, or written in non-English, or/and work only in Windows.</p>
<p>This tutorial focuses on creating a rhythm game without pain. Don't be surprised, we use Haskell to do that.</p>
<p>This tutorial has two parts.</p>
<ul>
<li>Part I contains an instruction to set up environment required for Part II and III.</li>
<li>In Part II, we build a very simple rhythm game. We use the Call engine to develop.</li>
<li>Part III introduces some technical backgrounds (graphics, audio) that support Part II.</li>
</ul>
<p>I'd be happy if this tutorial helps your curiosity to create a game.</p>
<h2 id="part-i-preparation">Part I: Preparation</h2>
<p>We need to ensure that you have installed GHC. <a href="https://www.haskell.org/platform/">Haskell Platform</a> is an easy way to install GHC.</p>
<p>On Unix or Mac, install <code>libportaudio19</code>.</p>
<p><strong>Note: Currently Call doesn't draw bitmaps well on Mac OS X. Please help me figure out what goes wrong.</strong></p>
<pre><code>$ sudo &lt;your-package-manager&gt; install libportaudio19</code></pre>
<p>The source code used in this tutorial is packed in <code>rhythm-game-tutorial</code> package. You can download it and set it up by:</p>
<pre><code>$ cabal update
$ cabal unpack rhythm-game-tutorial
$ cd rhythm-game-tutorial-&lt;version&gt;
$ cabal install --only-dependencies
% cabal configure
$ cabal build</code></pre>
<p><code>cabal install --only-dependencies</code> installs a bunch of packages, including two vital packages: <code>objective</code> and <code>call</code>.</p>
<ul>
<li><code>objective</code> establishes abstraction for stateful objects. It is not neccessary strictly, though it kills the pain of state significantly.</li>
<li><code>call</code> is a cross-platform multimedia library. While it is small and simple, the essentials of games (2D/3D graphics, audio, input handing from keyboard, mouse and gamepad) is assurable.</li>
<li><code>binding-portaudio</code> is low-level audio APIs.</li>
</ul>
<h3 id="on-windows">On windows</h3>
<p><code>bindings-portaudio</code> provides built-in source for installation ease. Unfortunately, due to a GHC bug, it is sometimes unstable. Note that using 32-bit version of GHC is safer to avoid problems if your platform is Windows x64.</p>
<pre class="shell"><code>$ cabal install bindings-portaudio -fBundle -fWASAPI</code></pre>
<p>If it throws up something messy, please report to me.</p>
<h2 id="part-ii-creating-a-game">Part II: Creating a game</h2>
<blockquote>
<p>Here we bang! -- Wada-don, &quot;Taiko no Tatsujin&quot;</p>
</blockquote>
<p>Now, think of a very simple game: There's a circle at the bottom of the window, and another circle(s) is approaching. You hit the space key in exact timing when the another circle overlapped the original one.</p>
<div class="figure">
<img src="images/tutorial-passive-screenshot.png" alt="tutorial-passive" />
<p class="caption">tutorial-passive</p>
</div>
<p>How do we implement this? The structure of the program can be derived by writing components down:</p>
<ul>
<li><strong>Sound</strong>: a music is playing through the game.</li>
<li><strong>Graphics</strong>: pictures depend on the time.</li>
<li><strong>Interaction</strong>: the score changes when the player hit the space key.</li>
</ul>
<p>We will explain these in order.</p>
<h3 id="playing-a-music">Playing a music</h3>
<p>Groove is important. It's time to play a music. Our first game is as follows(<code>src/music-only.hs</code>):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> runSystemDefault <span class="fu">$</span> <span class="kw">do</span>
  music <span class="ot">&lt;-</span> prepareMusic <span class="st">&quot;assets/Monoidal Purity.wav&quot;</span>
  playMusic music
  stand</code></pre>
<p>Let's execute it:</p>
<pre class="shell"><code>$ dist/build/music-only/music-only</code></pre>
<p>Can you hear the music? Note that it takes a moment to load a music.</p>
<p>Let's investigate the code. The following functions are provided by Call engine.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runSystemDefault ::</span> (forall s<span class="fu">.</span> <span class="dt">System</span> s a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">stand ::</span> <span class="dt">System</span> s ()</code></pre>
<p>In Call, actions are performed on <code>System s</code> monad. <code>runSystemDefault</code> converts <code>System s</code> into <code>IO</code>. <code>stand</code> does nothing, preventing termination of the program.</p>
<p>The signatures of <code>prepareMusic</code> and <code>playMusic</code> are as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Music</span> s <span class="fu">=</span> <span class="dt">Instance</span> (<span class="dt">StateT</span> <span class="dt">Deck</span> (<span class="dt">System</span> s)) (<span class="dt">System</span> s)

<span class="ot">prepareMusic ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">System</span> s (<span class="dt">Music</span> s)
<span class="ot">playMusic ::</span> <span class="dt">Music</span> s <span class="ot">-&gt;</span> <span class="dt">System</span> s ()</code></pre>
<p>These functions will be defined later.</p>
<h3 id="drawing-a-picture">Drawing a picture</h3>
<p>Let's construct a graphical part of the game.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> runSystemDefault <span class="fu">$</span> <span class="kw">do</span>
  allTimings <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> parseScore (<span class="dv">60</span><span class="fu">/</span><span class="dv">160</span><span class="fu">*</span><span class="dv">4</span>) <span class="fu">&lt;$&gt;</span> readFile <span class="st">&quot;assets/Monoidal Purity.txt&quot;</span>
  linkPicture <span class="fu">$</span> \_ <span class="ot">-&gt;</span> renderLane allTimings <span class="fu">&lt;$&gt;</span> getTime
  stand</code></pre>
<p><code>linkPicture :: (Time -&gt; System s Picture) -&gt; System ()</code> is the only function provided by Call to actually draw something.<code>linkPicture f</code> repeatedly calls <code>f</code> and draws the result of <code>f</code> to the window. The argument of <code>f</code> is the time difference between frames, it is often negligible though.</p>
<p>Due to its game system, we need to prepare the set of times. Let us introduce a new notation to represent timings which is more readable than just the list of decimals.</p>
<p>This notation is consist of a number of packets, representing a sequence of bars. Each packets contain several lines. A bar is divided by the length of line. '.' and '-' represents a note and a rest.</p>
<pre><code>----.-----------
.-----------.---
--------.-------</code></pre>
<p>The implementation of the parser is not so interesting.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseScore ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Set</span> <span class="dt">Time</span>]
parseScore d <span class="fu">=</span> map (Set.fromAscList <span class="fu">.</span> concat <span class="fu">.</span> zipWith (map <span class="fu">.</span> (<span class="fu">+</span>)) [<span class="dv">0</span>,d<span class="fu">..</span>]) <span class="fu">.</span> Data.List.transpose <span class="fu">.</span> map (map f) <span class="fu">.</span> splitWhen (<span class="fu">==</span><span class="st">&quot;&quot;</span>) <span class="fu">.</span> lines <span class="kw">where</span>
  f l <span class="fu">=</span> [t <span class="fu">|</span> (t, c) <span class="ot">&lt;-</span> zip [<span class="dv">0</span>, d<span class="fu">/</span>fromIntegral (length l)<span class="fu">..</span>] l, c <span class="fu">==</span> <span class="ch">&#39;.&#39;</span>]</code></pre>
<p>Given timings and &quot;life span&quot; of circles, we can compute positions of visible circles from the time.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">phases ::</span> <span class="dt">Set</span> <span class="dt">Time</span> <span class="co">-- ^ timings</span>
    <span class="ot">-&gt;</span> <span class="dt">Time</span> <span class="co">-- ^ life span</span>
    <span class="ot">-&gt;</span> <span class="dt">Time</span> <span class="co">-- ^ the current time</span>
    <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="co">-- ^ phase</span>
phases s len t <span class="fu">=</span> map ((<span class="fu">/</span>len) <span class="fu">.</span> subtract t) <span class="co">-- transform to an interval [0, 1]</span>
  <span class="fu">$</span> Set.toList
  <span class="fu">$</span> fst <span class="fu">$</span> Set.split (t <span class="fu">+</span> len) s <span class="co">-- before the limit</span></code></pre>
<p>Create a function to render circles. Since <code>Picture</code> is a monoid, we can use <code>foldMap</code> or <code>mconcat</code> to combine pictures. <code>translate (V2 x y)</code> shifts the picture into (x, y). <code>bitmap b</code> turns a <code>Bitmap</code> into a <code>Picture</code>.</p>
<p><code>unsafePerformIO</code>, which has the type <code>IO a -&gt; a</code>, looks really uncanny function. The use of <code>unsafePerformIO</code> must be limited to passive, <strong>virtually constant</strong> operations like <code>getArgs</code>, <code>readBitmap</code>, etc.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">circle_png ::</span> <span class="dt">Bitmap</span>
circle_png <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> readBitmap <span class="st">&quot;assets/circle.png&quot;</span>

<span class="ot">circles ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Picture</span>
circles <span class="fu">=</span> foldMap (\p <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dv">320</span> ((<span class="dv">1</span> <span class="fu">-</span> p) <span class="fu">*</span> <span class="dv">480</span>) <span class="ot">`translate`</span> bitmap circle_png)</code></pre>
<p><code>renderLane</code> passes the result of <code>phases</code> into <code>circles</code>. <code>color</code> changes a color of a picture.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">renderLane ::</span> <span class="dt">Set</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Picture</span>
renderLane ts t <span class="fu">=</span> mconcat [color blue <span class="fu">$</span> circles (phases ts <span class="dv">1</span> t)
    , <span class="dt">V2</span> <span class="dv">320</span> <span class="dv">480</span> <span class="ot">`translate`</span> color black (bitmap circle_png) <span class="co">-- criterion</span>
    ]</code></pre>
<p>Here is an updated <code>main</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> runSystemDefault <span class="fu">$</span> <span class="kw">do</span>
  music <span class="ot">&lt;-</span> prepareMusic <span class="st">&quot;assets/Monoidal-Purity.wav&quot;</span>
  allTimings <span class="ot">&lt;-</span> fmap (<span class="fu">!!</span><span class="dv">0</span>) <span class="fu">$</span> liftIO <span class="fu">$</span> loadTimings <span class="st">&quot;assets/Monoidal-Purity.txt&quot;</span>
  linkPicture <span class="fu">$</span> \_ <span class="ot">-&gt;</span> renderLane allTimings <span class="fu">&lt;$&gt;</span> getTime
  playMusic music
  stand</code></pre>
<p>There is a serious problem in this program. The graphics and music may <strong>diverge</strong> when the program has stumbled accidentally. We need to use the musical time instead of the real one.</p>
<h3 id="component-preparemusic">Component: prepareMusic</h3>
<p>A music is essential for rhythm games.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Music</span> s <span class="fu">=</span> <span class="dt">Instance</span> (<span class="dt">StateT</span> <span class="dt">Deck</span> (<span class="dt">System</span> s)) (<span class="dt">System</span> s)

<span class="ot">prepareMusic ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">System</span> s (<span class="dt">Music</span> s)
prepareMusic path <span class="fu">=</span> <span class="kw">do</span>
  wav <span class="ot">&lt;-</span> readWAVE path
  i <span class="ot">&lt;-</span> new <span class="fu">$</span> variable <span class="fu">$</span> source <span class="fu">.~</span> sampleSource wav <span class="fu">$</span> Deck.empty
  linkAudio <span class="fu">$</span> playbackOf i
  return i</code></pre>
<p><code>readWAVE</code> loads a sound from <code>.wav</code> file.<code>source .~ sampleSource wav $ Deck.empty</code> is a bit tricky.</p>
<p>Deck is an utility to play a music. <code>source</code> is a <code>Lens</code> which is purely functional representation of accessors. <code>new $ variable $ v</code> instantiates a music. Regard <code>linkAudio $ playbackOf i</code> as a cliché for now.</p>
<h3 id="component-getposition-and-playmusic">Component: getPosition and playMusic</h3>
<p>The implementation of <code>getPosition</code> and <code>playMusic</code> is as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getPosition ::</span> <span class="dt">Music</span> s <span class="ot">-&gt;</span> <span class="dt">System</span> s <span class="dt">Time</span>
getPosition m <span class="fu">=</span> m <span class="fu">.-</span> use pos

<span class="ot">playMusic ::</span> <span class="dt">Music</span> s <span class="ot">-&gt;</span> <span class="dt">System</span> s ()
playMusic m <span class="fu">=</span> m <span class="fu">.-</span> playing <span class="fu">.=</span> <span class="dt">True</span></code></pre>
<p>You notice two new operators: <code>use</code> and <code>.=</code>. These comes from the <code>lens</code> library. This package contains types and utilities to deal with various accessors.</p>
<p><code>pos</code>, <code>playing</code> are <code>Lens</code>. Given <code>Lens' s a</code>, you can take and modify a value <code>a</code> from <code>s</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pos ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Deck</span> <span class="dt">Time</span>
<span class="ot">playing ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Deck</span> <span class="dt">Bool</span></code></pre>
<p><code>use</code> and <code>(.=)</code> are getting/setting operators that work on stateful monads.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">use ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> m a
<span class="ot">(.=) ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m ()</code></pre>
<p>With lens, we can access a specific element of a structure easily, allowing you manipulate them just like &quot;fields&quot; in OOP languages. However, the state of the deck is packed in <code>music</code> in <code>gameMain</code> so these can't be used directly. The <code>(.-)</code> operator, provided by <code>objective</code> package, executes an action within a context held by a left operand.</p>
<p><code>getPosition m</code> returns an accurate time (in seconds) elapsed from an origin of a music <code>m</code>.</p>
<p>Putting them together, we got <code>src/tutorial-passive.hs</code>.</p>
<pre class="shell"><code>$ dist/build/tutorial-passive/tutorial-passive</code></pre>
<p>It is not a game though -- simply because it has no score, no interaction.</p>
<h3 id="handling-inputs">Handling inputs</h3>
<p>Let's deal with inputs. Now introduce two components, <code>rate</code> and <code>handle</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rate ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
rate dt
  <span class="fu">|</span> dt <span class="fu">&lt;</span> <span class="fl">0.05</span> <span class="fu">=</span> <span class="dv">4</span>
  <span class="fu">|</span> dt <span class="fu">&lt;</span> <span class="fl">0.1</span> <span class="fu">=</span> <span class="dv">2</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">1</span>

<span class="ot">handle ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Set</span> <span class="dt">Time</span>)
handle t ts <span class="fu">=</span> <span class="kw">case</span> viewNearest t ts <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (<span class="dv">0</span>, ts) <span class="co">-- The song is over</span>
  <span class="dt">Just</span> (t&#39;, ts&#39;) <span class="ot">-&gt;</span> (rate <span class="fu">$</span> abs (t <span class="fu">-</span> t&#39;), ts&#39;)</code></pre>
<p><code>rate</code> calculates a score from a time lag. <code>handle</code> returns a score and updated timings. <code>viewNearest :: (Num a, Ord a) =&gt; a -&gt; Set a -&gt; (a, Set a)</code> is a function to pick up the nearest value from a set. If we fail to attend to remove a nearest one, flamming the button causes undesired score increment.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Chatter</span> a <span class="fu">=</span> <span class="dt">Up</span> a <span class="fu">|</span> <span class="dt">Down</span> a</code></pre>
<p>And the following code actually handles events:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">linkKeyboard <span class="fu">$</span> \ev <span class="ot">-&gt;</span> <span class="kw">case</span> ev <span class="kw">of</span>
  <span class="dt">Down</span> <span class="dt">KeySpace</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
    t <span class="ot">&lt;-</span> getPosition
    ts <span class="ot">&lt;-</span> timings <span class="fu">.-</span> get
    (sc, ts&#39;) <span class="ot">&lt;-</span> handle t ts
    timings <span class="fu">.-</span> put ts&#39;
    score <span class="fu">.-</span> modify (<span class="fu">+</span>sc)
  _ <span class="ot">-&gt;</span> return () <span class="co">-- Discard the other events</span></code></pre>
<p>Note that a few variables has instantiated.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">timings <span class="ot">&lt;-</span> new <span class="fu">$</span> variable (allTimings <span class="fu">!!</span> <span class="dv">0</span>)
score <span class="ot">&lt;-</span> new <span class="fu">$</span> variable <span class="dv">0</span></code></pre>
<p>After <code>linkKeyboard</code> is called, the engine passes keyboard events <code>Key</code>. <code>Key</code> is wrapped by <code>Chatter</code> to indicate that a key is pressed, or released. When the space key is pressed, it computes the time difference from the nearest timing and increment the score by accuracy.</p>
<p>We need to load a <em>Font</em> as we want to show players the current score. <code>Call.Util.Text.simple</code> generates a function that renders a supplied text.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">text <span class="ot">&lt;-</span> Text.simple defaultFont <span class="dv">24</span> <span class="co">-- text :: String -&gt; Picture</span></code></pre>
<p>Just add <code>text (show sc)</code> to <code>renderGame</code>. <code>src/tutorial-active.hs</code> is the updated source we made interactive. It's a game, yay!</p>
<pre class="shell"><code>$ dist/build/tutorial-passive/tutorial-active</code></pre>
<div class="figure">
<img src="images/tutorial-active-screenshot.png" alt="tutorial-active" />
<p class="caption">tutorial-active</p>
</div>
<h3 id="extending-the-game">Extending the game</h3>
<p>However, when you actually play this, you may feel dissatisfied. It is because the interaction is still poor. If it would have more showy effects, it'll be exciting. Most rhythm games shows the recent evaluation of the accuracy immediately. So, players can notice whether their playing is good or bad.</p>
<p>Thanks to purely functional design, we can extend lanes so easily(<code>tutorial-extended.hs</code>)!</p>
<div class="figure">
<img src="images/extended.png" alt="extended" />
<p class="caption">extended</p>
</div>
<p><code>ix i</code> is a lens that points an <code>i</code>-th element of a list. Just arrange the result of <code>forM</code> using <code>translate</code>.</p>
<p>Another interesting feature, <code>transit</code>, is convenient to create animations.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Effect</span> m <span class="fu">=</span> <span class="dt">Mortal</span> (<span class="dt">Request</span> <span class="dt">Time</span> <span class="dt">Picture</span>) m ()

<span class="ot">pop ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Effect</span> m
pop bmp <span class="fu">=</span> <span class="dt">Mortal</span> <span class="fu">$</span> transit <span class="fl">0.5</span> <span class="fu">$</span> \t <span class="ot">-&gt;</span> translate (<span class="dt">V2</span> <span class="dv">320</span> <span class="dv">360</span>)
  <span class="fu">$</span> translate (<span class="dt">V2</span> <span class="dv">0</span> (<span class="fu">-</span><span class="dv">80</span>) <span class="fu">^*</span> t)
  <span class="fu">$</span> color (<span class="dt">V4</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> (realToFrac <span class="fu">$</span> <span class="dv">1</span> <span class="fu">-</span> t))
  <span class="fu">$</span> bitmap bmp</code></pre>
<p>The argument <code>t</code> varies from 0 to 1, for 0.5 seconds. To instantiate this, put this object into a list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">effects <span class="ot">&lt;-</span> new <span class="fu">$</span> variable []
effects <span class="fu">.-</span> modify (pop _perfect_png<span class="fu">:</span>)</code></pre>
<p>And <code>effects .- gatherFst id (apprises (request dt))</code> returns <code>Picture</code>, removing expired animations automatically. It benefits from <code>objective</code> much. Here is the complete <code>linkPicture</code> section.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">linkPicture <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span>
  [l0, l1, l2] <span class="ot">&lt;-</span> forM [<span class="dv">0</span><span class="fu">..</span><span class="dv">2</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span> renderLane <span class="fu">&lt;$&gt;</span> (timings <span class="fu">.-</span> use (ix i)) <span class="fu">&lt;*&gt;</span> getPosition music
  s <span class="ot">&lt;-</span> score <span class="fu">.-</span> get
  ps <span class="ot">&lt;-</span> effects <span class="fu">.-</span> gatherFst id (apprises (request dt))
  return <span class="fu">$</span> translate (<span class="dt">V2</span> (<span class="fu">-</span><span class="dv">120</span>) <span class="dv">0</span>) l0
    <span class="fu">&lt;&gt;</span> translate (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">0</span>) l1
    <span class="fu">&lt;&gt;</span> translate (<span class="dt">V2</span> <span class="dv">120</span> <span class="dv">0</span>) l2
    <span class="fu">&lt;&gt;</span> color black (translate (<span class="dt">V2</span> <span class="dv">240</span> <span class="dv">40</span>) (text (show s)))
    <span class="fu">&lt;&gt;</span> ps</code></pre>
<p>There is no difficulty around input.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> touchLane i <span class="fu">=</span> <span class="kw">do</span>
      ((sc, obj), ts&#39;) <span class="ot">&lt;-</span> handle <span class="fu">&lt;$&gt;</span> getPosition music <span class="fu">&lt;*&gt;</span> (timings <span class="fu">.-</span> use (ix i))
      effects <span class="fu">.-</span> modify (obj<span class="fu">:</span>)
      timings <span class="fu">.-</span> ix i <span class="fu">.=</span> ts&#39;
      score <span class="fu">.-</span> modify (<span class="fu">+</span>sc)

linkKeyboard <span class="fu">$</span> \ev <span class="ot">-&gt;</span> <span class="kw">case</span> ev <span class="kw">of</span>
  <span class="dt">Down</span> <span class="dt">KeySpace</span> <span class="ot">-&gt;</span> touchLane <span class="dv">1</span>
  <span class="dt">Down</span> <span class="dt">KeyF</span> <span class="ot">-&gt;</span> touchLane <span class="dv">0</span>
  <span class="dt">Down</span> <span class="dt">KeyJ</span> <span class="ot">-&gt;</span> touchLane <span class="dv">2</span>
  _ <span class="ot">-&gt;</span> return () <span class="co">-- Discard the other events</span></code></pre>
<p>Moreover, with <code>LambdaCase</code> GHC extension, you can replace <code>\ev -&gt; case ev of</code> with <code>\case</code>.</p>
<p>The overall game goes in only 123 lines!</p>
<pre class="shell"><code>$ wc -l src\tutorial-extended.hs
123
$ dist/build/tutorial-passive/tutorial-extended</code></pre>
<h2 id="part-iii-technical-background">Part III: Technical background</h2>
<h3 id="graphics">Graphics</h3>
<p>Monoid is the general term for composable stuff which has &quot;empty&quot;. A picture is one of the monoids since there is an <strong>empty picture</strong> and pictures <strong>can be composed</strong> by overlaying. The standard library <code>base</code> provides a typeclass for monoids:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">  mempty ::</span> a
<span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>Call uses <strong>free monoid</strong> to represent picture.</p>
<p>In de-CPSed form,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Scene</span> <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="fu">|</span> <span class="dt">Combine</span> <span class="dt">Scene</span> <span class="dt">Scene</span>
  <span class="fu">|</span> <span class="dt">Primitive</span> <span class="dt">Bitmap</span> <span class="dt">PrimitiveMode</span> (<span class="dt">Vector</span> <span class="dt">Vertex</span>) <span class="co">-- draw a primitive</span>
  <span class="fu">|</span> <span class="dt">VFX</span> (<span class="dt">VFX</span> <span class="dt">Scene</span>) <span class="co">-- apply visual effects</span>
  <span class="fu">|</span> <span class="dt">Transform</span> (<span class="dt">M44</span> <span class="dt">Float</span>) <span class="dt">Scene</span> <span class="co">-- transform `Scene` using a matrix</span></code></pre>
<p>Its Monoid instance is trivial.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Scene</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Empty</span>
  mappend <span class="fu">=</span> <span class="dt">Combine</span></code></pre>
<p>Using free monoid, we can isolate the drawing process from <code>Scene</code>. Think of <code>drawScene :: Scene -&gt; IO ()</code> which calls concrete APIs to draw Scene. For empty picture, we don't do nothing. <code>Combine a b</code> is equivalent to calling <code>drawScene a &gt;&gt; drawScene b</code>.</p>
<p>So the implementation of <code>drawScene</code> will be as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">drawScene <span class="dt">Empty</span> <span class="fu">=</span> return ()
drawScene (<span class="dt">Combine</span> a b) <span class="fu">=</span> drawScene a <span class="fu">&gt;&gt;</span> drawScene b
drawScene (<span class="dt">Primitive</span> b m vs) <span class="fu">=</span> drawPrimitive b m vs
drawScene (<span class="dt">VFX</span> v) <span class="fu">=</span> drawScene (applyVFX v)
drawScene (<span class="dt">Transform</span> mat s) <span class="fu">=</span> withMatrix mat (drawScene s)</code></pre>
<p>where <code>drawPrimitive</code>, <code>applyVFX</code>, <code>withMatrix</code> are environment-dependent.</p>
<p>In other words, free structures are kinds of DSL which encourages the reusability of programs. Andres Löh's <a href="https://skillsmatter.com/skillscasts/4430-monads-for-free">Monads for free!</a> is a great introduction for free structures.</p>
<p>Call puts together a few kinds of transformation in <code>Affine</code> class. Thanks to type families, we can use the same operation for both 2D and 3D. <code>Normal</code> is the normal vector, which is 3-dimensional vector in 3D but it is just <code>Float</code> in 2D.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Affine</span> a <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Vec</span><span class="ot"> a ::</span> <span class="fu">*</span>
  <span class="kw">type</span> <span class="dt">Normal</span><span class="ot"> a ::</span> <span class="fu">*</span>
<span class="ot">  rotateOn ::</span> <span class="dt">Normal</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  scale ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  translate ::</span> <span class="dt">Vec</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<h3 id="audio">Audio</h3>
<p>Currently, there are few packages for audio that work in common platforms and are easy to install. I choosed <code>portaudio</code> for now which supports a bunch of backends. Humans are so sensitive about sound; 20 miliseconds of latency is noticable for us.</p>
<p>Thus, it is important to minimize latency when it comes to audio. This is the main reason of why call relies on callback. The call library aims to be small and concrete, leaving abstraction to <code>objective</code>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Special thanks to Kazuhiko Yamamoto for guidance of the architecture of this tutorial.</p>
